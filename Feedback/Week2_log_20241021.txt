Starting code feedback for Saskia, Week2

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 1.97 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: .git, Week3, Feedback, Week1, Week2

Found the following files in parent directory: .gitignore, README.md

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:

**********************************************************************
*~ 
*.tmp
.DS_Store

**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
CMEECourseWork1
Overview

This repository contains coursework for the Computational Methods in Ecology and Evolution (CMEE) programming bootcamp. The repository is organized into weekly folders, with each week focusing on different tools and programming languages used in ecological and evolutionary modeling.

Each week contains four subfolders:

    Code: Contains all the scripts written during the coursework.
    Data: Holds datasets used for the analysis and exercises.
    Results: Stores the output generated by the code, such as processed data and results.
    Sandbox: A space for experimental or draft scripts and testing different approaches.

Week 1: Bash and Linux Shell Scripting

Purpose: This folder contains exercises and scripts related to the basics of Bash and Linux shell commands.

    Code: Contains shell scripts (.sh files) that demonstrate:
        Command-line tools for file manipulation (e.g., grep, awk, sed).
        Automating tasks with bash scripts.
        File and directory handling, and piping commands.
    Data: Input files used by the bash scripts, such as text files, log files, or tabular data.
    Results: Output generated by the shell scripts.
    Sandbox: Contains draft or experimental bash scripts for testing purposes.

Week 2: Python Scripting (Part 1)

Purpose: This folder focuses on exercises related to Python programming, primarily for data manipulation, analysis, and basic scripting.

    Code: Contains Python scripts (.py files) demonstrating:
        Basic Python syntax and data structures (lists, dictionaries, sets).
        File I/O operations (reading/writing .csv, .txt files).
        Simple data analysis and processing tasks.
        Example: align_seqs.py which aligns DNA sequences.
    Data: CSV or text files used as input for the Python scripts.
    Results: Output generated from Python scripts, such as processed data or visualization outputs.
    Sandbox: A space for testing experimental Python code or trying out new libraries.

Week 3: R Programming

Purpose: This folder contains exercises related to R programming, primarily for statistical analysis and data visualization.

    Code: Contains R scripts (.R files) focusing on:
        Basic R syntax and functions.
        Data manipulation with dplyr and tidyverse.
        Generating plots and visualizations with ggplot2.
        Statistical analyses and ecological modeling.
    Data: Datasets used for the R scripts, typically in .csv format.
    Results: Contains outputs from R scripts, such as plots, summary statistics, and analysis results.
    Sandbox: A space for testing new approaches or experimenting with R packages.

Week 4: Python Scripting (Part 2)

Purpose: This folder is a continuation of Python scripting, focusing on more advanced topics like working with APIs, data structures, and scientific libraries like NumPy, Pandas, and Matplotlib.

    Code: Contains Python scripts (.py files) demonstrating:
        Advanced data manipulation and analysis using Pandas.
        Working with external APIs or data sources.
        Generating scientific plots using Matplotlib or Seaborn.
        Example: control_flow.py for control structures in Python.
    Data: Files used for analysis in the Python scripts, typically in .csv format.
    Results: Output generated by the scripts, including tables, plots, or other analyses.
    Sandbox: A place to experiment with new Python techniques or libraries.

How to Use This Repository

    Clone the repository:

    bash

git clone https://github.com/username/CMEECourseWork.git

Navigate to the relevant week: Each week has a separate folder for Code, Data, Results, and Sandbox. Go to the relevant week and subfolder:

bash

    cd CMEECourseWork/Week2/Code

    Run the scripts: You can run the scripts from the command line or within your preferred environment (Python, R, or bash terminal).

    View results: Output from the scripts is saved in the Results folder of the respective week.

Prerequisites

    Python: Ensure you have Python 3 installed. Some scripts may require additional packages such as NumPy, Pandas, or Matplotlib. Install these using:

    bash

    pip install -r requirements.txt

    R: For Week 3, ensure you have R installed along with the required R packages (e.g., dplyr, ggplot2).
    Bash: The Week 1 scripts require a Unix-based environment with basic Linux utilities.


**********************************************************************

======================================================================
Looking for the weekly directories...

Found 3 weekly directories: Week1, Week2, Week3

The Week2 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK2...

Found the following directories: Results, Code, Data, Sandbox

Found the following files: .gitignore

Checking for readme file in weekly directory...

README file missing, 1 pt deducted

Current Points = 99

Found following files in results directory: DNA_seq.txt, JustOaksData.csv...

Ideally, Results directory should be empty other than, perhaps a .gitkeep. 

 0.5 pts deducted per results file 

Current Points = 98.0

Found 22 code files: basic_io1.py, basic_csv.py, tuple.py, basic_io2.py, scope.py, basic_io3.py, lc2.py, cfexercise1.py, sysargv.py, test_control_flow.py, lc1.py, oaks.py, oaks_debugme.py, cfexercise2.py, MyExampleScript.py, control_flow.py, align_seqs.py, loops.py, boilerplate.py, using_name.py, debugme.py, dictionary.py

Found the following extra files: README.md
0.5 pt deducted per extra file

Current Points = 97.5

======================================================================
Testing script/code files...

======================================================================
Inspecting script file basic_io1.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""Basic python data import and exports, 
prints line if length greater than 0"""
__appname__ = "basic_io1"
__author__ = 'Saskia Pearce (sp621@imperial.ac.uk)'
__version__ = '3.9'

#############################
# FILE INPUT
#############################
# Open a file for reading
f = open('../sandbox/test.txt', 'r')
# use "implicit" for loop:
# if the object is a file, python will cycle over lines
for line in f:
    print(line)

# close the file
f.close()

# Same example, skip blank lines
f = open('../sandbox/test.txt', 'r')
for line in f:
    if len(line.strip()) > 0:
        print(line)

f.close()

**********************************************************************

Testing basic_io1.py...

basic_io1.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 97.5

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2024-25/Coursework/StudentRepos/SaskiaPearce_sp621/Week2/Code/basic_io1.py", line 12, in <module>
    f = open('../sandbox/test.txt', 'r')
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: '../sandbox/test.txt'

======================================================================
Inspecting script file basic_csv.py...

File contents are:

**********************************************************************
"""Basic python data import and exports, 
handling CSV files """
__appname__ = "basic_io3"
__author__ = 'Saskia Pearce (sp621@imperial.ac.uk)'
__version__ = '3.9'

import csv

# Read a file containing:
# 'Species','Infraorder','Family','Distribution','Body mass male (Kg)'
with open('../data/testcsv.csv','r') as f:

    csvread = csv.reader(f)
    temp = []
    for row in csvread:
        temp.append(tuple(row))
        print(row)
        print("The species is", row[0])

# write a file containing only species name and Body mass
with open('../data/testcsv.csv','r') as f:
    with open('../data/bodymass.csv','w') as g:

        csvread = csv.reader(f)
        csvwrite = csv.writer(g)
        for row in csvread:
            print(row)
            csvwrite.writerow([row[0], row[4]])


**********************************************************************

Testing basic_csv.py...

basic_csv.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 97.5

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2024-25/Coursework/StudentRepos/SaskiaPearce_sp621/Week2/Code/basic_csv.py", line 11, in <module>
    with open('../data/testcsv.csv','r') as f:
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: '../data/testcsv.csv'

======================================================================
Inspecting script file tuple.py...

File contents are:

**********************************************************************
""" Using Tuples """
__appname__ = "Tuples"
__author__ = 'Saskia Pearce (sp621@imperial.ac.uk)'
__version__ = '3.9'

birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

# Birds is a tuple of tuples of length three: latin name, common name, mass.
# write a (short) script to print these on a separate line or output block by
# species 
# 
# A nice example output is:
# Latin name: Passerculus sandwichensis Common name: Savannah sparrow Mass: 18.7
# ... etc.

for i in range(4):
        print("Latin name:", birds[(i)][0], "Common name:", birds[(i)][1], "Mass:", birds[(i)][2]) 


**********************************************************************

Testing tuple.py...

tuple.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 97.5

Output (only first 500 characters): 


**********************************************************************
Latin name: Passerculus sandwichensis Common name: Savannah sparrow Mass: 18.7
Latin name: Delichon urbica Common name: House martin Mass: 19
Latin name: Junco phaeonotus Common name: Yellow-eyed junco Mass: 19.5
Latin name: Junco hyemalis Common name: Dark-eyed junco Mass: 19.6

**********************************************************************

Code ran without errors

Time consumed = 0.02176s

======================================================================
Inspecting script file basic_io2.py...

File contents are:

**********************************************************************
"""Basic python data import and exports, 
saving the elements of a list to a file"""
__appname__ = "basic_io2"
__author__ = 'Saskia Pearce (sp621@imperial.ac.uk)'
__version__ = '3.9'

#############################
# FILE OUTPUT
#############################
# Save the elements of a list to a file
list_to_save = range(100)

f = open('../sandbox/testout.txt','w')
for i in list_to_save:
    f.write(str(i) + '\n') ## Add a new line at the end

f.close()
**********************************************************************

Testing basic_io2.py...

basic_io2.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 97.5

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2024-25/Coursework/StudentRepos/SaskiaPearce_sp621/Week2/Code/basic_io2.py", line 13, in <module>
    f = open('../sandbox/testout.txt','w')
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: '../sandbox/testout.txt'

======================================================================
Inspecting script file scope.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""demonstartions of variable scopes, 
including local and global variables"""
__appname__ = "scope"
__author__ = 'Saskia Pearce (sp621@imperial.ac.uk)'
__version__ = '3.9'

#local variables
y = 1
x = 0
for y in range(10):
    x += 1
print(y)
print(x)

i = 1
x = 0

y, x # or print(i, x)
(1, 0)

for y in range(10):
    x += 1
y, x


# x was updated to 10 due to successive simmation that the loop performs and y, which was originally 1 has now become 10 
i = 1
x = 0
def a_function(y):
    x = 0
    for i in range(y):
        x += 1
    return x
a_function(10)
print(i)
print(x)

#this is now a fucntion
i = 1
x = 0
def a_function(y):
    x = 0
    for i in range(y):
        x += 1
    return x

a_function(10)
x =a_function(10)

#global variables 
_a_global = 10 # a global variable

if _a_global >= 5:
    _b_global = _a_global + 5 # also a global variable
    
print("Before calling a_function, outside the function, the value of _a_global is", _a_global)
print("Before calling a_function, outside the function, the value of _b_global is", _b_global)

def a_function():
    _a_global = 4 # a local variable
    
    if _a_global >= 4:
        _b_global = _a_global + 5 # also a local variable
    
    _a_local = 3
    
    print("Inside the function, the value of _a_global is", _a_global)
    print("Inside the function, the value of _b_global is", _b_global)
    print("Inside the function, the value of _a_local is", _a_local)
    
a_function()

print("After calling a_function, outside the function, the value of _a_global is (still)", _a_global)
print("After calling a_function, outside the function, the value of _b_global is (still)", _b_global)
print("After calling a_function, outside the function, the value of _a_local is ", _a_local)

_a_global = 10

print("Before calling a_function, outside the function, the value of _a_global is", _a_global)

def a_function():
    """This function modifies the global variable `_a_global` by assigning it the value 5."""
    global _a_global # global makes it modifyed out of the function
    _a_global = 5
    _a_local = 4
    
    print("Inside the function, the value of _a_global is", _a_global)
    print("Inside the function, the value _a_local is", _a_local)
    
a_function()

print("After calling a_function, outside the function, the value of _a_global now is", _a_global)

def modify_list_1(some_list):
    """Demonstrates reassignment of a list inside a function, which does not modify the original list."""
    print('got', some_list)
    some_list = [1, 2, 3, 4]
    print('set to', some_list)

my_list = [1, 2, 3]

print('before, my_life =', my_list)

before, my_list = [1, 2, 3]

modify_list_1(my_list)

print('after, my_list =', my_list)

def modify_list_3(some_list):
    """
    Appends the value 4 to a given list and prints the list before and after modification """
    print('got', some_list)
    some_list.append(4) # an actual modification of the list
    print('changed to', some_list)


my_list = modify_list_3(my_list)

print('after, my_life =', my_list)

x = []
for i in range(10):
    x.append(i)
print(x)

x = [i for i in range(10)]
print(x)

x = [i.lower() for i in ["list", "comprehensions", "are", "cool"]]
print
#basically a shortened version of a loop

**********************************************************************

Testing scope.py...

scope.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 96.0

Output (only first 500 characters): 


**********************************************************************
9
10
1
0
Before calling a_function, outside the function, the value of _a_global is 10
Before calling a_function, outside the function, the value of _b_global is 15
Inside the function, the value of _a_global is 4
Inside the function, the value of _b_global is 9
Inside the function, the value of _a_local is 3
After calling a_function, outside the function, the value of _a_global is (still) 10
After calling a_function, outside the function, the value of _b_global is (still) 15

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2024-25/Coursework/StudentRepos/SaskiaPearce_sp621/Week2/Code/scope.py", line 76, in <module>
    print("After calling a_function, outside the function, the value of _a_local is ", _a_local)
                                                                                       ^^^^^^^^
NameError: name '_a_local' is not defined. Did you mean: '_a_global'?

======================================================================
Inspecting script file basic_io3.py...

File contents are:

**********************************************************************
"""Basic python data import and exports, 
saving a complex object into a dictionary"""
__appname__ = "basic_io3"
__author__ = 'Saskia Pearce (sp621@imperial.ac.uk)'
__version__ = '3.9'

#############################
# STORING OBJECTS
#############################
# To save an object (even complex) for later use
my_dictionary = {"a key": 10, "another key": 11}

import pickle 

f = open('../sandbox/testp.p','wb') ## note the b: accept binary files
pickle.dump(my_dictionary, f)
f.close()

## Load the data again
f = open('../sandbox/testp.p','rb')
another_dictionary = pickle.load(f)
f.close()

print(another_dictionary)

**********************************************************************

Testing basic_io3.py...

basic_io3.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 96.0

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2024-25/Coursework/StudentRepos/SaskiaPearce_sp621/Week2/Code/basic_io3.py", line 15, in <module>
    f = open('../sandbox/testp.p','wb') ## note the b: accept binary files
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: '../sandbox/testp.p'

======================================================================
Inspecting script file lc2.py...

File contents are:

**********************************************************************
""" Comprehensions and lists """
__appname__ = "lc2"
__author__ = 'Saskia Pearce (sp621@imperial.ac.uk)'
__version__ = '3.9'

# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )

# (1) Use a list comprehension to create a list of month,rainfall tuples where
# the amount of rain was greater than 100 mm.
rain = [(month, amount) for month, amount in rainfall if amount >100]
print(rain) #pinrts rainfall over 100 mm

 
# (2) Use a list comprehension to create a list of just month names where the
# amount of rain was less than 50 mm. 

rain = [(month, amount) for month, amount in rainfall if amount <50]
print(rain) #prints rain fall less than 50 mm

 

# (3) Now do (1) and (2) using conventional loops (you can choose to do 
# this before 1 and 2 !). 

rain100 = []

for month, amount in rainfall: 
    if amount>100:
        rain100.append((month, amount)) #add to new empty rain100 list 

print(rain100)

rain50 = []

for month, amount in rainfall: 
    if amount<50:
        rain50.append((month, amount)) #add to new empty rain100 list 

print(rain50)
    

# A good example output is:

#
# Step #1:
# Months and rainfall values when the amount of rain was greater than 100mm:
# [('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
# ... etc.
**********************************************************************

Testing lc2.py...

lc2.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 96.0

Output (only first 500 characters): 


**********************************************************************
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
[('MAR', 49.9), ('SEP', 27.0)]
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
[('MAR', 49.9), ('SEP', 27.0)]

**********************************************************************

Code ran without errors

Time consumed = 0.02016s

======================================================================
Inspecting script file cfexercise1.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""Creating a function called foo and running the function"""
__appname__ = "cfexercise1"
__author__ = 'Saskia Pearce (sp621@imperial.ac.uk)'
__version__ = '0.0.1'

import sys
import doctest

x_default = 3
y_default = 13
z_default = 90

def foo_1(x=x_default):
    """Calculate the square root of a given number

    Args:
        x (float or int): The number to find the square root of. Should be non-negative. Default is 3.

    Returns:
        float or int: The square root of x.

    Example:
        >>> foo_1(4)
        2.0
        >>> foo_1(9)
        3.0
        >>> foo_1(16)
        4.0
    """
    return x ** 0.5


def foo_2(x=x_default, y=y_default):
    """Calculates and returns the larger of two numbers.
    
    Args: 
        x (float or int): The first number. Default is 3.
        y (float or int): The second number. Default is 13.

    Returns:
        float or int: The larger of x and y.

    Example:
        >>> foo_2()
        13
        >>> foo_2(10, 5)
        10
        >>> foo_2(7, 14)
        14
    """
    return x if x > y else y


def foo_3(x=x_default, y=y_default, z=z_default):
    """Orders 3 numbers in ascending order 

    Args:
        x (int or float): The first number, default is 3.
        y (int or float): The second number, default is 13.
        z (int or float): The third number, default is 90.

    Returns:
        list: A list of the three numbers sorted in ascending order.

    Example:
        >>> foo_3()
        [3, 13, 90]
        >>> foo_3(15, 5, 10)
        [5, 10, 15]
    """
    nums = [x, y, z]
    nums.sort()
    return nums


def foo_4(x=x_default):
    """Calculates the factorial of an input value

    Args:
        x (int): The number to calculate the factorial of. Should be a non-negative integer.
                 Default is 3.

    Returns:
        int: The factorial of x.

    Example:
        >>> foo_4(5)
        120
        >>> foo_4(3)
        6
    """
    result = 1
    for i in range(1, x + 1):
        result = result * i
    return result


def foo_5(x=x_default):
    """Calculates the factorial of x (recursive implementation)

    Args:
        x (int): The number to calculate the factorial of. Should be a non-negative integer.
                 Default is 3.

    Returns:
        int: The factorial of x.

    Example:
        >>> foo_5(5)
        120
        >>> foo_5(3)
        6
    """
    if x == 1:
        return 1
    return x * foo_5(x - 1)


def foo_6(x=x_default):
    """Calculates the factorial of x (iterative implementation)

    Args:
        x (int): The number to calculate the factorial of. Should be a non-negative integer.
        Default is 3.

    Returns:
        int: The factorial of x.

    Example:
        >>> foo_6(5)
        120
        >>> foo_6(3)
        6
    """
    facto = 1
    while x >= 1:
        facto = facto * x
        x = x - 1
    return facto


if __name__ == "__main__":  
    doctest.testmod()  # Run all the doctests in the module
    # You can include main and exit handling if you want more functionality.




**********************************************************************

Testing cfexercise1.py...

cfexercise1.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 96.0

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.05941s

======================================================================
Inspecting script file sysargv.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""A  program which uses the argv agrument variable to uphol arguemtns passed in the script when run """
__appname__ = 'sysargv'
__author__ = '[Saskia (sp621@ic.ac.uk)]'
__version__ = '3.9'

import sys 
#imput, %run sysargv.py var1 var2
print("this is the name of the script: ", sys.argv[0]) #the first argument is printed, the name of the program
print("Number of arguments: ", len(sys.argv)) #3 arguements 
print('the arguments are: ', str(sys.argv)) # file name, var1 and var2


**********************************************************************

Testing sysargv.py...

sysargv.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 96.0

Output (only first 500 characters): 


**********************************************************************
this is the name of the script:  sysargv.py
Number of arguments:  1
the arguments are:  ['sysargv.py']

**********************************************************************

Code ran without errors

Time consumed = 0.01980s

======================================================================
Inspecting script file test_control_flow.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""Some functions exemplifying the use of control statements"""
#docstrings are considered part of the running code (normal comments are
#stripped). Hence, you can access your docstrings at run time.
__appname__ = "test_control_flows"
__author__ = 'Saskia Pearce (sp621@imperial.ac.uk)'
__version__ = '3.9'

import sys
import doctest #import the doctest module
#!/usr/bin/env python3

def even_or_odd(x=0):
    """Find whether a number x is even or odd.
      
    >>> even_or_odd(10)
    '10 is Even!'
    
    >>> even_or_odd(5)
    '5 is Odd!'
        
    in case of negative numbers, the positive is taken:    
    >>> even_or_odd(-2)
    '-2 is Even!'
    
    """
    #Define function to be tested
    if x % 2 == 0:
        return f"{x} is Even!"
    return f"{x} is Odd!"

def main(argv): 
    """
    Main function to test the `even_or_odd` function by printing results for specific values.
    """
    print(even_or_odd(22))
    print(even_or_odd(33))
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)

doctest.testmod()   # To run with embedded tests 

**********************************************************************

Testing test_control_flow.py...

test_control_flow.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 96.0

Output (only first 500 characters): 


**********************************************************************
22 is Even!
33 is Odd!

**********************************************************************

Code ran without errors

Time consumed = 0.05300s

======================================================================
Inspecting script file lc1.py...

File contents are:

**********************************************************************
""" Comprehensions and lists """
__appname__ = "lc1"
__author__ = 'Saskia Pearce (sp621@imperial.ac.uk)'
__version__ = '3.9'


birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )

#(1) Write three separate list comprehensions that create three different
# lists containing the latin names, common names and mean body masses for
# each species in birds, respectively.
# List comprehension to extract Latin names
Latin = [i[0] for i in birds] #the first values taken from the list 

# List comprehension to extract common names
Common = [i[1] for i in birds]

# List comprehension to extract mean body masses
Mass = [i[2] for i in birds]

# Print the lists
print("Latin names:", Latin)
print("Common names:", Common)
print("Masses:", Mass)

# (2) Now do the same using conventional loops (you can choose to do this 
# before 1 !). 

latin = [] #create new empty list 
common = []
Mass = []

for bird in birds: 
    latin.append(bird[0]) #add values to the list 
    common.append(bird[1])
    Mass.append(bird[2])

print("Latin names:", latin) #print result 
print("Common names:", common)
print("Masses:", Mass)


**********************************************************************

Testing lc1.py...

lc1.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 96.0

Output (only first 500 characters): 


**********************************************************************
Latin names: ['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
Common names: ['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
Masses: [18.7, 19, 19.5, 19.6, 20.2]
Latin names: ['Passerculus sandwichensis', 'Delichon urbica', 'Junco phaeonotus', 'Junco hyemalis', 'Tachycineata bicolor']
Common names: ['Savannah sparrow', 'House martin', 'Yellow-eyed junco', 'Dark-eyed junco', 'Tree swallow']
Ma
**********************************************************************

Code ran without errors

Time consumed = 0.02245s

======================================================================
Inspecting script file oaks.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""Finds just those taxa which are oak trees from a list of species, 
using loops and comprehensions"""
__appname__ = "Oaks"
__author__ = 'Saskia Pearce (sp621@imperial.ac.uk)'
__version__ = '3.9'

taxa = [ 'Quercus robur',
         'Fraxinus excelsior',
         'Pinus sylvestris',
         'Quercus cerris',
         'Quercus petraea',
       ]


def is_an_oak(name):
    """
    Check if the given tree name corresponds to an oak species.
    """
    return name.lower().startswith('quercus')  # Ensure consistent indentation with 4 spaces



oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species)
print(oaks_loops)

##Using list comprehensions   
oaks_lc = set([species for species in taxa if is_an_oak(species)])
print(oaks_lc)


##Get names in UPPER CASE using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species.upper())
print(oaks_loops)

##Get names in UPPER CASE using list comprehensions
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)])
print(oaks_lc)

##Get names in UPPER CASE using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species.upper())
print(oaks_loops)

##Get names in UPPER CASE using list comprehensions
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)])
print(oaks_lc)
**********************************************************************

Testing oaks.py...

oaks.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 96.0

Output (only first 500 characters): 


**********************************************************************
{'Quercus petraea', 'Quercus robur', 'Quercus cerris'}
{'Quercus petraea', 'Quercus robur', 'Quercus cerris'}
{'QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'}
{'QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'}
{'QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'}
{'QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'}

**********************************************************************

Code ran without errors

Time consumed = 0.02285s

======================================================================
Inspecting script file oaks_debugme.py...

File contents are:

**********************************************************************
""" Identifying species that belong to the genus Quercus from a CSV file """
#docstrings are considered part of the running code (normal comments are
#stripped). Hence, you can access your docstrings at run time.
__appname__ = "oaks_debugme"
__author__ = 'Saskia Pearce (sp621@imperial.ac.uk)'
__version__ = '3.9'

import csv #import depednencies for csv input and exports 
import sys
import doctest

#Define function
def is_an_oak(name):
    """
    Returns True if name starts with 'quercus'

    Examples:
    >>> is_an_oak('Quercus robur')
    True
    >>> is_an_oak('Quercus cerris')
    True
    >>> is_an_oak('Quercus petraea')
    True
    >>> is_an_oak('Quercussomething')
    False
    >>> is_an_oak('Fraxinus excelsior')
    False
    >>> is_an_oak('Pinus sylvestris')
    False
    """
    oakname = name.lower().strip()
    return oakname == 'quercus' or oakname.startswith('quercus ') #strip gets rid of spaces before and after the genus name 


def main(argv): 
    """Processes a CSV file to extract rows containing oak species and writes them to a new CSV file."""
    f = open('../Data/TestOaksData.csv','r') #read original input csv 
    g = open('../Results/JustOaksData.csv','w') #write new csv 
    taxa = csv.reader(f)
    csvwrite = csv.writer(g)
    oaks = set() #creates new set for matches 
    for row in taxa:
        print(row)
        print ("The genus is: ") 
        print(row[0] + '\n')
        if is_an_oak(row[0]):
            print('FOUND AN OAK!\n')
            csvwrite.writerow([row[0], row[1]])    

    return 0
    
if __name__ == "__main__":
    import doctest
    doctest.testmod() #doc test tests the fucntion works above , if the genus names match usisng the test examples 
    status = main(sys.argv)
**********************************************************************

Testing oaks_debugme.py...

oaks_debugme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 96.0

Output (only first 500 characters): 


**********************************************************************
['Genus', ' species']
The genus is: 
Genus

['Quercus', ' robur']
The genus is: 
Quercus

FOUND AN OAK!

['Fraxinus', ' excelsior']
The genus is: 
Fraxinus

['Pinus', ' sylvestris']
The genus is: 
Pinus

['Quercus', ' cerris']
The genus is: 
Quercus

FOUND AN OAK!

['Quercus', ' petraea']
The genus is: 
Quercus

FOUND AN OAK!


**********************************************************************

Code ran without errors

Time consumed = 0.06550s

======================================================================
Inspecting script file cfexercise2.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""Examples of loops and conditionals combined, 
using for and while loops"""
__appname__ = "cfexercise2"
__author__ = 'Saskia Pearce (sp621@imperial.ac.uk)'
__version__ = '3.9'

########################
def hello_1(x): 
    """Prints 'hello' for every multiple of 3 up to the given number, 
    followed by a blank line."""
    for j in range(x):# so youd have to set x
        if j % 3 == 0: 
            print('hello')
    print(' ')

hello_1(12)

########################
def hello_2(x): 
    """
    Prints 'hello' or 'hello2' based on specific conditions for numbers in a range.
    
    Prints 'hello' when the number leaves a remainder of 3 when divided by 5.
    Prints 'hello2' when the number leaves a remainder of 3 when divided by 4.
    """
    for j in range(x):
        if j % 5 == 3:
            print('hello')
        elif j % 4 == 3: 
            print('hello2')
    print()  # This will print a blank line at the end

# Calling the function
hello_2(12)

########################
def hello_3(x, y): 
    """Prints 'hello' for each number in the range between `x` and `y`."""
    for i in range(x, y): 
        print('hello')
    print(' ')


hello_3(40, 100)

########################
def hello_4(x):
    """Prints 'hello' repeatedly until the value of `x` becomes 15."""
    while x != 15: 
        print('hello')
        x = x + 3
    print('')


hello_4(0)

########################
def hello_5(x): 
    """Prints 'hello' based on specific conditions while incrementing `x` until it reaches 100."""
    while x < 100: 
        if x == 31: 
            for k in range(7):
                print('hello')
        elif x == 18: 
            print('hello')
        x = x + 1
    print(' ')

hello_5(1)

#While loop with a break!
def hello_6(x, y): 
    """Prints 'hello!' followed by a number until the value of `y` reaches 6, then breaks the loop"""
    while x: 
        print("hello!" + str(y))
        y += 1 
        if y == 6:
            break
    print(' ')


hello_6 (True, 0)

**********************************************************************

Testing cfexercise2.py...

cfexercise2.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 96.0

Output (only first 500 characters): 


**********************************************************************
hello
hello
hello
hello
 
hello
hello2
hello
hello2

hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
 
hello
hello
hello
hello
hello

hello
hello
hello
hello
hello
hello
hello
hello
 
hello
**********************************************************************

Code ran without errors

Time consumed = 0.02525s

======================================================================
Inspecting script file MyExampleScript.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""Creating a function called foo"""
__appname__ = "MyExampleScript"
__author__ = 'Saskia Pearce (sp621@imperial.ac.uk)'
__version__ = '3.9'

#The Python function foo takes a single parameter x, multiplies it by itself (squares it), prints the result, and then returns that squared value.
def foo(x):
     """
    Squares the input value and prints the result.

    This function takes an input `x`, squares it (multiplies it by itself), and prints the result.

    Args:
        x (int or float): The number to be squared.

    Returns:
        None: This function does not return a value; it only prints the result.

    Example:
        >>> foo(2)
        4
        >>> foo(5)
        25
        >>> foo(3.5)
        12.25
    """
     x *= x # same as x = x*x
     print(x)

foo(2)


**********************************************************************

Testing MyExampleScript.py...

MyExampleScript.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 96.0

Output (only first 500 characters): 


**********************************************************************
4

**********************************************************************

Code ran without errors

Time consumed = 0.02429s

======================================================================
Inspecting script file control_flow.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""Some functions exemplifying the use of control statements"""
#docstrings are considered part of the running code (normal comments are
#stripped). Hence, you can access your docstrings at run time.
__appname__ = "Control_flows"
__author__ = 'Saskia Pearce (sp621@imperial.ac.uk)'
__version__ = '3.9'

import sys

# Prompt the user to enter a value

def even_or_odd(x=0): # if not specified, x should take value 0.

    """Find whether a number x is even or odd."""
    if x % 2 == 0: #The conditional if
        return f"{x} is Even!"
    return f"{x} is Odd!"

def largest_divisor_five(x=120):
    """Find which is the largest divisor of x among 2,3,4,5."""
    largest = 0
    if x % 5 == 0:
        largest = 5
    elif x % 4 == 0: #means "else, if"
        largest = 4
    elif x % 3 == 0:
        largest = 3
    elif x % 2 == 0:
        largest = 2
    else: # When all other (if, elif) conditions are not met
        return f"No divisor found for {x}!" # Each function can return a value or a variable.
    return f"The largest divisor of {x} is {largest}"

def is_prime(x=70):
    """Find whether an integer is prime."""
    for i in range(2, x): #  "range" returns a sequence of integers
        if x % i == 0:
            print(f"{x} is not a prime: {i} is a divisor") 
            return False
    print(f"{x} is a prime!")
    return True 

def find_all_primes(x=22):
    """Find all the primes up to x"""
    allprimes = []
    for i in range(2, x + 1):
        if is_prime(i):
            allprimes.append(i)
    print(f"There are {len(allprimes)} primes between 2 and {x}")
    return allprimes
      
def main(argv):
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(largest_divisor_five(120))
    print(largest_divisor_five(121))
    print(is_prime(60))
    print(is_prime(59))
    print(find_all_primes(100))
    return 0

if (__name__ == "__main__"): # If the script is imported as a module in another script, __name__ is set to the module’s name instead.
    status = main(sys.argv) # brings calls the funtion main and passed it to sys.argv, to look for inputted elements
    sys.exit(status)
**********************************************************************

Testing control_flow.py...

control_flow.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Missing docstring, either in one or functions and/or at the script level

Current Points = 95.5

Output (only first 500 characters): 


**********************************************************************
22 is Even!
33 is Odd!
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
2 is a prime!
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is not a prime: 3 is a divisor
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is not a prime: 3 is a divisor
16 is 
**********************************************************************

Code ran without errors

Time consumed = 0.02127s

======================================================================
Inspecting script file align_seqs.py...

File contents are:

**********************************************************************
"""Code to align two DNA sequences"""
#docstrings are considered part of the running code (normal comments are
#stripped). Hence, you can access your docstrings at run time.
__appname__ = "align_seqs"
__author__ = 'Saskia Pearce (sp621@imperial.ac.uk)'
__version__ = '3.9'

# Two example sequences to match
# takes DNA sequences from csv file 
# saves score into a text file (../Results)
# python align_seq <- input 

#search the csv for sequences, separated by commas

import csv #for inputing and exporting csv

with open('../data/ .csv', 'r') as f: 

    csvread = csv.reader(f)
    sequences = []
    for row in csvread:
        for sequence in row:
            sequences.append(sequence)
            print("DNA sequence:", sequence)

# Assign the longer sequence s1, and the shorter to s2
# l1 is length of the longest, l2 that of the shortest

seq2 = (sequences[0]) #sequence taken from csv file 
seq1 = (sequences[1])

l1 = len(seq1) #assign longested sequence from file 
l2 = len(seq2) 
if l1 >= l2:
    s1 = seq1
    s2 = seq2
else:
    s1 = seq2
    s2 = seq1
    l1, l2 = l2, l1 # swap the two lengths

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    """
    Calculate the alignment score between two DNA sequences starting from a specified position.

    This function aligns a portion of sequence `s2` with sequence `s1` starting at the given 
    `startpoint`. It compares the bases of both sequences, adds to the score if they match, 
    and prints the alignment visually with '*' indicating a match and '-' indicating a mismatch.

    Args:
        s1 (str): The first DNA sequence (usually the longer one).
        s2 (str): The second DNA sequence (usually the shorter one to be aligned with `s1`).
        l1 (int): The length of sequence `s1`.
        l2 (int): The length of sequence `s2`.
        startpoint (int): The starting position in `s1` where the alignment with `s2` begins.

    Returns:
        int: The alignment score representing the number of matching bases between `s1` and `s2`.

    Example:
        >>> calculate_score("AGCTGAC", "GCT", 7, 3, 1)
        .***
        .GCT
        AGCTGAC
        3
    """
    matched = "" # to hold string displaying alignements
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched)      #startpoitn has to shift up every time       
    print("." * startpoint + s2)
    print(s1)
    print(score) 
    print(" ")

    return score

# Test the function with some example starting points:
# calculate_score(s1, s2, l1, l2, 0)
# calculate_score(s1, s2, l1, l2, 1)
# calculate_score(s1, s2, l1, l2, 5)


results = '../results/alignment_results.txt'

# now try to find the best match (highest score) for the two sequences
my_best_align = None
my_best_score = -1 #alignment will always be higher than this starting score

f = open('../Results/DNA_seq.txt','w')
for i in range(l1): # Note that you just take the last alignment with the highest score
    z = calculate_score(s1, s2, l1, l2, i) #arguement in the file 
    if z > my_best_score:
        my_best_align = "." * i + s2 # think about what this is doing!
        my_best_score = z 
        f.write("Best alignment:\n")
        f.write(f"{my_best_align}\n{s1}\n")
        f.write(f"Best score: {my_best_score}\n")

f.close()

print(my_best_align)
print(s1)
print("Best score:", my_best_score) # best score printed

**********************************************************************

Testing align_seqs.py...

align_seqs.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 95.5

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2024-25/Coursework/StudentRepos/SaskiaPearce_sp621/Week2/Code/align_seqs.py", line 17, in <module>
    with open('../data/ .csv', 'r') as f: 
         ^^^^^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: '../data/ .csv'

======================================================================
Inspecting script file loops.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""Some simple loops using 'for' and 'while'"""
__appname__ = "loops"
__author__ = 'Saskia Pearce (sp621@imperial.ac.uk)'
__version__ = '3.9'

# FOR loops
for i in range(5): #range 5 sets the amount of iterations 
    print(i) #print results 

my_list = [0, 2, "geronimo!", 3.0, True, False] # lists can contain different variable classes
for k in my_list:
    print(k)

total = 0
summands = [0, 1, 11, 111, 1111]
for s in summands:
    total = total + s
    print(total)

# WHILE loop
z = 0
while z < 100:
    z = z + 1
    print(z)
**********************************************************************

Testing loops.py...

loops.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 95.5

Output (only first 500 characters): 


**********************************************************************
0
1
2
3
4
0
2
geronimo!
3.0
True
False
0
1
12
123
1234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100

**********************************************************************

Code ran without errors

Time consumed = 0.02058s

======================================================================
Inspecting script file boilerplate.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""A simple boilerplate program which prints, this is a boilerplate """
__appname__ = 'BoilerplateApp'
__author__ = '[Saskia (sp621@ic.ac.uk)]'
__version__ = '3.9'
__license__ = "license for this code/program"

##imports##
import sys # module to interface our profram with the operating system 

## constants ## these do not chnage through the funciton eg PI = 3.14159

##functions ##
def main(argv): #defining a function, argv is the “argument variable”
    """main entry point of the progrom """ 
    print('this is a boilerplate') #prints text 
    return 0 

if __name__ == "__main__": #conditional if command
    """makes sure the 'main' funtion is called from command line"""
    status = main(sys.argv) #directs the interpreter to pass the argument variables to the main function.
    sys.exit(status) #terminate and exit the python program, status = 0 

**********************************************************************

Testing boilerplate.py...

boilerplate.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 95.5

Output (only first 500 characters): 


**********************************************************************
this is a boilerplate

**********************************************************************

Code ran without errors

Time consumed = 0.02207s

======================================================================
Inspecting script file using_name.py...

File contents are:

**********************************************************************
#!/usr/bin/env python3
"""A  program which assigns a name to a module using __name__ """
__appname__ = 'Using_name'
__author__ = '[Saskia (sp621@ic.ac.uk)]'
__version__ = '3.9'
__license__ = "license for this code/program"

#Filename: using_name.py
if __name__ == '__main__': #special built-in variable (__name__), meaning python knows if a file is being imported to another file or run directly 
    print('the program is being run by itself !')
else: 
    print('I am being imported from another script/program/module!')

print("this module's name is: " + __name__) 


**********************************************************************

Testing using_name.py...

using_name.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 95.5

Output (only first 500 characters): 


**********************************************************************
the program is being run by itself !
this module's name is: __main__

**********************************************************************

Code ran without errors

Time consumed = 0.02973s

======================================================================
Inspecting script file debugme.py...

File contents are:

**********************************************************************
"""Debugging a peice of code, using a debugger"""
__appname__ = "debugme"
__author__ = 'Saskia Pearce (sp621@imperial.ac.uk)'
__version__ = '3.9'

def buggyfunc(x): #define the function 
    """This function has an error when y reaches 0
    default value """
    y = x 
    for i in range(x):
        y = y-1 
        #break in the running of the function, stops at the end of the first iteration 
        #import ipdb; ipdb.set_trace() #iimports a module and sets a break point, runs module by iteration by iteration, you can follow the values by printing c.

        z = x/y
    return z

buggyfunc(20) #start with 20 , 20-19, z = 20/19. 



# you cant devide a number by 0, so an error ocurs 
**********************************************************************

Testing debugme.py...

debugme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 95.5

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Traceback (most recent call last):
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2024-25/Coursework/StudentRepos/SaskiaPearce_sp621/Week2/Code/debugme.py", line 18, in <module>
    buggyfunc(20) #start with 20 , 20-19, z = 20/19. 
    ^^^^^^^^^^^^^
  File "/home/mhasoba/Documents/Teaching/IC_CMEE/2024-25/Coursework/StudentRepos/SaskiaPearce_sp621/Week2/Code/debugme.py", line 15, in buggyfunc
    z = x/y
        ~^~
ZeroDivisionError: division by zero

======================================================================
Inspecting script file dictionary.py...

File contents are:

**********************************************************************
""" Using Dictionaries """
__appname__ = "Dictionary"
__author__ = 'Saskia Pearce (sp621@imperial.ac.uk)'
__version__ = '3.9'

taxa = { ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
         }



taxa_dic = {} # create an empty dictionary to add to

# Populate taxa_dic with orders mapped to sets of species
for species, order in taxa:
    if order not in taxa_dic:
        taxa_dic[order] = set()  # Create a set for this order if it doesn't already exist
    taxa_dic[order].add(species)  # Add the species to the appropriate order set

# Print the resulting dictionary
for order, species_set in taxa_dic.items():
    print("\n" f"'{order}': {species_set}")



taxa_dic = {order: {species for species, o in taxa if o == order} for _, order in taxa}

# Print the resulting dictionary
for order, species_set in taxa_dic.items():
    print("\n" f"'{order}': {species_set}")
 


**********************************************************************

Testing dictionary.py...

dictionary.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 95.5

Output (only first 500 characters): 


**********************************************************************

'Rodentia': {'Cleithrionomys rutilus', 'Gerbillus henleyi', 'Mus domesticus', 'Peromyscus crinitus'}

'Carnivora': {'Canis lupus', 'Lyacon pictus', 'Arctocephalus gazella'}

'Chiroptera': {'Myotis lucifugus'}

'Afrosoricida': {'Microgale talazaci', 'Microgale dobsoni'}

'Rodentia': {'Cleithrionomys rutilus', 'Gerbillus henleyi', 'Mus domesticus', 'Peromyscus crinitus'}

'Carnivora': {'Canis lupus', 'Lyacon pictus', 'Arctocephalus gazella'}

'Chiroptera': {'Myotis lucifugus'}

'Afrosoricida': {'M
**********************************************************************

Code ran without errors

Time consumed = 0.02156s

======================================================================
======================================================================
Finished running scripts

Ran into 7 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 95.5

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!