Starting testing for Saskia, Week3

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 2.36 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week1, Week3, .git, Week2, Feedback

Found the following files in parent directory: .gitignore, README.md

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:

**********************************************************************
*~ 
*.tmp
.DS_Store

**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
CMEECourseWork1
Overview

This repository contains coursework for the Computational Methods in Ecology and Evolution (CMEE) programming bootcamp. The repository is organized into weekly folders, with each week focusing on different tools and programming languages used in ecological and evolutionary modeling.

Each week contains four subfolders:

    Code: Contains all the scripts written during the coursework.
    Data: Holds datasets used for the analysis and exercises.
    Results: Stores the output generated by the code, such as processed data and results.
    Sandbox: A space for experimental or draft scripts and testing different approaches.

Week 1: Bash and Linux Shell Scripting

Purpose: This folder contains exercises and scripts related to the basics of Bash and Linux shell commands.

    Code: Contains shell scripts (.sh files) that demonstrate:
        Command-line tools for file manipulation (e.g., grep, awk, sed).
        Automating tasks with bash scripts.
        File and directory handling, and piping commands.
    Data: Input files used by the bash scripts, such as text files, log files, or tabular data.
    Results: Output generated by the shell scripts.
    Sandbox: Contains draft or experimental bash scripts for testing purposes.

Week 2: Python Scripting (Part 1)

Purpose: This folder focuses on exercises related to Python programming, primarily for data manipulation, analysis, and basic scripting.

    Code: Contains Python scripts (.py files) demonstrating:
        Basic Python syntax and data structures (lists, dictionaries, sets).
        File I/O operations (reading/writing .csv, .txt files).
        Simple data analysis and processing tasks.
        Example: align_seqs.py which aligns DNA sequences.
    Data: CSV or text files used as input for the Python scripts.
    Results: Output generated from Python scripts, such as processed data or visualization outputs.
    Sandbox: A space for testing experimental Python code or trying out new libraries.

Week 3: R Programming

Purpose: This folder contains exercises related to R programming, primarily for statistical analysis and data visualization.

    Code: Contains R scripts (.R files) focusing on:
        Basic R syntax and functions.
        Data manipulation with dplyr and tidyverse.
        Generating plots and visualizations with ggplot2.
        Statistical analyses and ecological modeling.
    Data: Datasets used for the R scripts, typically in .csv format.
    Results: Contains outputs from R scripts, such as plots, summary statistics, and analysis results.
    Sandbox: A space for testing new approaches or experimenting with R packages.

Week 4: Python Scripting (Part 2)

Purpose: This folder is a continuation of Python scripting, focusing on more advanced topics like working with APIs, data structures, and scientific libraries like NumPy, Pandas, and Matplotlib.

    Code: Contains Python scripts (.py files) demonstrating:
        Advanced data manipulation and analysis using Pandas.
        Working with external APIs or data sources.
        Generating scientific plots using Matplotlib or Seaborn.
        Example: control_flow.py for control structures in Python.
    Data: Files used for analysis in the Python scripts, typically in .csv format.
    Results: Output generated by the scripts, including tables, plots, or other analyses.
    Sandbox: A place to experiment with new Python techniques or libraries.

How to Use This Repository

    Clone the repository:

    bash

git clone https://github.com/username/CMEECourseWork.git

Navigate to the relevant week: Each week has a separate folder for Code, Data, Results, and Sandbox. Go to the relevant week and subfolder:

bash

    cd CMEECourseWork/Week2/Code

    Run the scripts: You can run the scripts from the command line or within your preferred environment (Python, R, or bash terminal).

    View results: Output from the scripts is saved in the Results folder of the respective week.

Prerequisites

    Python: Ensure you have Python 3 installed. Some scripts may require additional packages such as NumPy, Pandas, or Matplotlib. Install these using:

    bash

    pip install -r requirements.txt

    R: For Week 3, ensure you have R installed along with the required R packages (e.g., dplyr, ggplot2).
    Bash: The Week 1 scripts require a Unix-based environment with basic Linux utilities.


**********************************************************************

======================================================================
Looking for the weekly directories...

Found 3 weekly directories: Week1, Week2, Week3

The Week3 directory will be tested 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Testing WEEK3...

Found the following directories: Results, Code, Data, Sandbox

Found the following files: README.md

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
CMEECourseWork

Title: Week 3 Biological Computing Bootcamp

Brief Description:

This repository contains coursework for the Computational Methods in Ecology and Evolution (CMEE), specifically focusing on biological computing tasks using Linux and shell scripting. The exercises are based on TheMulQuaBio course notes (https://mhasoba.github.io/TheMulQuaBio/intro.html) from the Biological Computing course at the Department of Life Sciences, Imperial College London.

Project Structure and Usage: The repository contains code scripts located in the Code folder. The Data folder includes input files used by some scripts, while the sandbox folder contains experimental files and is not essential to the main coursework. Output files are generated in the results folder for this week’s coursework.

Project Structure

    Code folder: Contains all scripts.
    Data folder: Includes input files used by scripts.
    Results folder: Stores output files generated by the scripts.
    Sandbox folder: Used for experimental work (not essential for the coursework).

Languages: 
R version 4.4.0 

Dependencies: 
ggplot2
plyr (Practical)
ddply (Practical) 
tidyverse

Installation:

To clone this repository, use the following command:
bash
git clone git@github.com:Saskiapearce/CMEECourseWork.git

Project Structure and Usage:
The repository contains 10 primary scripts located in the Code folder. The Data folder includes input files used by some scripts, while the sandbox folder contains experimental files and is not essential to the main coursework. Output files are generated in the results folder for this week’s coursework.

apply1.R

    Purpose: Calculates the mean and variance for each row and the mean for each column of a randomly generated matrix.
    Usage: Run the script directly in R to generate a matrix, compute row and column statistics, and display results.
    Input: No external input. A 10x10 matrix is generated internally.
    Output:
        Prints the mean of each row.
        Prints the variance of each row.
        Prints the mean of each column.
    Example Run:

    r

    source("apply1.R")
    # Output will show RowMeans, RowVars, and ColMeans

apply2.R

    Purpose: Applies a custom function SomeOperation to each row of a matrix, multiplying rows by 100 if their sum is greater than 0, or leaving them unchanged otherwise.
    Usage: Run the script directly to apply SomeOperation to each row of a randomly generated 10x10 matrix.
    Input: No external input. A 10x10 matrix is generated within the script.
    Output: Prints the matrix after applying SomeOperation to each row.
    Example Run:

    r

    source("apply2.R")
    # Output will show the transformed matrix

basic_io.R

    Purpose: Demonstrates basic input and output (I/O) operations in R, including reading and writing CSV files, checking data structure, and saving modified data.
    Usage: Run the script in an R environment that has access to ../data/trees.csv to read, view, and write data.
    Input:
        ../data/trees.csv: A CSV file containing tree data.
    Output:
        Prints various data structures to the console, including class and structure information for Mydata.
        Saves a modified version of MyData as ../Results/MyData.csv.
    Dependencies: Requires trees.csv in the ../data/ directory.
    Example Run:

    r

    source("basic_io.R")
    # Console output displays information on Mydata, and MyData.csv is saved in ../Results

boilerplate.R

    Purpose: Provides a template function MyFunction that takes two arguments, prints their types, and returns them.
    Usage: Run the script directly to execute MyFunction with sample arguments.
    Input: No external input. Sample arguments are provided within the script.
    Output: Prints the type of each argument passed to MyFunction.
    Example Run:

    r

    source("boilerplate.R")
    # Output:
    # Argument 1 is a numeric
    # Argument 2 is a numeric
    # Argument Riki is a character
    # Argument Tiki is a character

break.R

    Purpose: Demonstrates a while loop in R that increments a counter i and prints its value until i reaches 10, at which point the loop breaks.
    Usage: Run the script directly to observe the loop behavior and how it breaks when i reaches 10.
    Input: No external input.
    Output: Prints the values of i from 0 to 9, with a message indicating each value.
    Example Run:

    r

    source("break.R")
    # Output:
    # i equals 0
    # i equals 1
    # ...
    # i equals 9

browse.R

    Purpose: Simulates exponential growth over a specified number of generations and allows interactive debugging with the browser() function.
    Usage: Run the script to simulate exponential growth with customizable parameters (N0, r, and generations).
    Input:
        N0: Initial population size.
        r: Growth rate.
        generations: Number of generations to simulate.
    Output: A line plot showing exponential growth over the specified generations.
    Example Run:

    r

    source("browse.R")
    # An interactive debug session will open at each generation

control_flow.R

    Purpose: Demonstrates basic control flow in R, including if statements, for loops, and while loops.
    Usage: Run the script to observe examples of control flow structures.
    Input: No external input; the script generates its own data.
    Output: Prints results of various conditional checks and loops to the console.
    Example Run:

    r

    source("control_flow.R")
    # Console output shows results of if statements, for loops, and while loops

DataWrang.R

    Purpose: Performs data wrangling by cleaning, transforming, and reshaping data into a tidy format.
    Usage: Run the script to import and wrangle data from the PoundHillData.csv file.
    Input:
        ../data/PoundHillData.csv: Raw dataset.
        ../data/PoundHillMetaData.csv: Metadata for context.
    Output:
        Prints wrangled data to the console.
        Creates a tidy dataset (MyWrangledData).
    Dependencies: Requires tidyverse for data manipulation.
    Example Run:

    r

    source("DataWrang.R")
    # Console output shows wrangled data, filtered subsets, and summaries

Girko.R

    Purpose: Plots the eigenvalues of a random matrix and overlays them with an ellipse to illustrate Girko’s circular law.
    Usage: Run the script to generate a random matrix, compute eigenvalues, and plot the results with a circular boundary.
    Input: No external input.
    Output: A plot showing the eigenvalues of the random matrix and an ellipse representing the theoretical boundary.
    Dependencies: Requires tidyverse and ggplot2 for plotting.
    Example Run:

    r

    source("Girko.R")
    # Displays a plot with eigenvalues and an elliptical boundary

MyBars.R

    Purpose: Creates a bar plot with multiple line ranges representing data series, with annotations.
    Usage: Run the script to read Results.txt, process the data, and plot multiple line ranges with colors and labels.
    Input:
        ../data/Results.txt: Data file with columns for plotting.
    Output: A bar plot with line ranges and annotations.
    Dependencies: Requires tidyverse and ggplot2 for plotting.
    Example Run:

    r

    source("MyBars.R")
    # Displays a customized bar plot with line ranges and labels

next.R

    Purpose: Demonstrates the next statement in R to skip iterations in a loop. Only prints odd numbers from 1 to 10.
    Usage: Run the script to see how next is used to skip even numbers.
    Input: No external input required.
    Output: Prints only odd numbers between 1 and 10.
    Example Run:

    r

    source("next.R")
    # Output:
    # [1] 1
    # [1] 3
    # [1] 5
    # [1] 7
    # [1] 9

plotLin.R

    Purpose: Generates a linear dataset with noise, performs linear regression, and visualizes data with a regression line and color gradient based on residuals.
    Usage: Run the script to create a scatter plot with a regression line and color gradient.
    Input: None; data is generated within the script.
    Output: A plot showing the linear regression line with residual-based color shading.
    Dependencies: Requires ggplot2 for plotting.
    Example Run:

    r

    source("plotLin.R")
    # Outputs a ggplot with a linear regression line and color gradient

preallocate.R

    Purpose: Compares execution time between a function with pre-allocated memory and one without, to demonstrate efficiency.
    Usage: Run the script to see time differences between two vector assignment methods.
    Input: No external input.
    Output: Prints time taken for each function and displays vector contents and memory usage per iteration.
    Dependencies: Requires ggplot2 for the final plot.
    Example Run:

    r

    source("preallocate.R")
    # Output shows time taken by each function and memory allocation details

R_conditionals.R

    Purpose: Provides functions to check if a number is even, a power of 2, or prime.
    Usage: Run the script to call each function with example arguments.
    Input: Numeric values as arguments.
    Output: Prints results indicating if numbers are even, powers of 2, or prime.
    Example Run:

    r

    source("R_conditionals.R")
    is.even(6)        # Output: "6 is even!"
    is.power2(4)      # Output: "4 is a power of 2!"
    is.prime(3)       # Output: "3 is a prime!"

sample.R

    Purpose: Performs a sampling experiment and demonstrates iteration methods, including preallocation and vectorization with sapply and lapply.
    Usage: Run the script to compare execution times of different sampling methods.
    Input: No external input; generates a random population.
    Output:
        Histogram of the population distribution.
        Execution times for each sampling method.
    Example Run:

    r

    source("sample.R")
    # Outputs execution times and displays histogram of population

TreeHeight.R

    Purpose: Calculates tree heights based on angle and distance measurements, then saves results to a CSV file.
    Usage: Run the script to read a CSV file with tree data, calculate heights, and save results.
    Input:
        ../data/trees.csv: CSV file with angles and distances.
    Output:
        Prints calculated tree heights.
        Saves results to ../results/TreedataR.csv.
    Example Run:

    r

    source("TreeHeight.R")
    # Console outputs calculated heights and saves them in TreedataR.csv

try.R

    Purpose: Demonstrates error handling in R using try, sampling a population and calculating the mean only if the sample has sufficient unique values.
    Usage: Run the script to observe error handling when samples lack unique values.
    Input: No external input; generates a random population.
    Output: Prints the mean of the sample if calculated, or an error message.
    Example Run:

    r

    source("try.R")
    # Console output shows mean values or error messages based on sample uniqueness

Vectorize1.R

    Purpose: Compares time taken to sum all matrix elements using a loop versus a vectorized function.
    Usage: Run the script to see the execution time difference.
    Input: No external input; generates a random matrix.
    Output: Prints time taken for both summing methods.
    Example Run:

    r
    source("Vectorize1.R")
    # Console output shows execution times for both summing methods

Author infomation: 
	Saskia Pearce 
	Sp621@ic.ac.uk
**********************************************************************

Results directory is empty - good! 

Found 18 code files: break.R, sample.R, Vectorize1.R, R_conditionals.R, apply1.R, basic_io.R, Girko.R, boilerplate.R, apply2.R, DataWrang.R, try.R, control_flow.R, MyBars.R, TreeHeight.R, plotLin.R, next.R, browse.R, preallocate.R

======================================================================
Testing script/code files...

======================================================================
Inspecting script file break.R...

File contents are:

**********************************************************************


i <- 0 #Initialize i 
while (i < Inf) {
  if (i == 10) {
    break 
  } else { #break out of the loop !
    cat("i equals ", i , "\n")
    i <- i + 1 #update i 
    }
}

**********************************************************************

Testing break.R...

Output (only first 500 characters): 


**********************************************************************
i equals  0 
i equals  1 
i equals  2 
i equals  3 
i equals  4 
i equals  5 
i equals  6 
i equals  7 
i equals  8 
i equals  9 

**********************************************************************

Code ran without errors

Time consumed = 0.11269s

======================================================================
Inspecting script file sample.R...

File contents are:

**********************************************************************
######### Functions ##########

## A function to take a sample of size n from a population "popn" and return its mean
myexperiment <- function(popn,n) {
  pop_sample <- sample(popn, n, replace = FALSE)
  return(mean(pop_sample))
}

## Calculate means using a FOR loop on a vector without preallocation:
loopy_sample1 <- function(popn, n, num) {
  result1 <- vector() #Initialize empty vector of size 1 
  for(i in 1:num) {
    result1 <- c(result1, myexperiment(popn, n))
  }
  return(result1)
}

## To run "num" iterations of the experiment using a FOR loop on a vector with preallocation:
loopy_sample2 <- function(popn, n, num) {
  result2 <- vector(,num) #Preallocate expected size
  for(i in 1:num) {
    result2[i] <- myexperiment(popn, n)
  }
  return(result2)
}

## To run "num" iterations of the experiment using a FOR loop on a list with preallocation:
loopy_sample3 <- function(popn, n, num) {
  result3 <- vector("list", num) #Preallocate expected size
  for(i in 1:num) {
    result3[[i]] <- myexperiment(popn, n)
  }
  return(result3)
}


## To run "num" iterations of the experiment using vectorization with lapply:
lapply_sample <- function(popn, n, num) {
  result4 <- lapply(1:num, function(i) myexperiment(popn, n))
  return(result4)
}

## To run "num" iterations of the experiment using vectorization with sapply:
sapply_sample <- function(popn, n, num) {
  result5 <- sapply(1:num, function(i) myexperiment(popn, n))
  return(result5)
}

set.seed(12345)
popn <- rnorm(10000) # Generate the population
hist(popn)

n <- 100 # sample size for each experiment
num <- 10000 # Number of times to rerun the experiment

print("Using loops without preallocation on a vector took:" )
print(system.time(loopy_sample1(popn, n, num)))

print("Using loops with preallocation on a vector took:" )
print(system.time(loopy_sample2(popn, n, num)))

print("Using loops with preallocation on a list took:" )
print(system.time(loopy_sample3(popn, n, num)))

print("Using the vectorized sapply function (on a list) took:" )
print(system.time(sapply_sample(popn, n, num)))

print("Using the vectorized lapply function (on a list) took:" )
print(system.time(lapply_sample(popn, n, num)))


**********************************************************************

Testing sample.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Using loops without preallocation on a vector took:"
   user  system elapsed 
  0.171   0.017   0.188 
[1] "Using loops with preallocation on a vector took:"
   user  system elapsed 
  0.116   0.000   0.115 
[1] "Using loops with preallocation on a list took:"
   user  system elapsed 
  0.121   0.000   0.120 
[1] "Using the vectorized sapply function (on a list) took:"
   user  system elapsed 
  0.119   0.000   0.118 
[1] "Using the vectorized lapply function (on a list) took:"
   user  syst
**********************************************************************

Code ran without errors

Time consumed = 0.84023s

======================================================================
Inspecting script file Vectorize1.R...

File contents are:

**********************************************************************
M <- matrix(runif(1000000),1000,1000)

SumAllElements <- function(M) {
  Dimensions <- dim(M)
  Tot <- 0
  for (i in 1:Dimensions[1]) {
    for (j in 1:Dimensions[2]) {
      Tot <- Tot + M[i,j]
    }
  }
  return (Tot)
}

print("Using loops, the time taken is:")
print(system.time(SumAllElements(M)))

print("Using the in-built vectorized function, the time taken is:")
print(system.time(sum(M)))
**********************************************************************

Testing Vectorize1.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Using loops, the time taken is:"
   user  system elapsed 
  0.029   0.001   0.031 
[1] "Using the in-built vectorized function, the time taken is:"
   user  system elapsed 
  0.002   0.000   0.001 

**********************************************************************

Code ran without errors

Time consumed = 0.15748s

======================================================================
Inspecting script file R_conditionals.R...

File contents are:

**********************************************************************
# Checks if an integer is even
is.even <- function(n = 2) {
  if (n %% 2 == 0) {
    return(paste(n,'is even!'))
  } else {
    return(paste(n,'is odd!'))
  }
}

is.even(6)

# Checks if a number is a power of 2
is.power2 <- function(n = 2) {
  if (log2(n) %% 1==0) {
    return(paste(n, 'is a power of 2!'))
  } else {
    return(paste(n,'is not a power of 2!'))
  }
}

is.power2(4)

# Checks if a number is prime
is.prime <- function(n) {
  if (n==0) {
    return(paste(n,'is a zero!'))
  } else if (n==1) {
    return(paste(n,'is just a unit!'))
  }
  
  ints <- 2:(n-1)
  
  if (all(n%%ints!=0)) {
    return(paste(n,'is a prime!'))
  } else {
    return(paste(n,'is a composite!'))
  }
}

is.prime(3)



**********************************************************************

Testing R_conditionals.R...

Output (only first 500 characters): 


**********************************************************************
[1] "6 is even!"
[1] "4 is a power of 2!"
[1] "3 is a prime!"

**********************************************************************

Code ran without errors

Time consumed = 0.08722s

======================================================================
Inspecting script file apply1.R...

File contents are:

**********************************************************************
## Build a random matrix
M <- matrix(rnorm(100), 10, 10) #you dont want to apply tapply to a datafram as first it is coerce into a matrix and then you might loss important imformation about the data as matrixs can only handle 1 data type 

## Take the mean of each row
RowMeans <- apply(M, 1, mean)
print (RowMeans)

## Now the variance
RowVars <- apply(M, 1, var)
print (RowVars)

## By column
ColMeans <- apply(M, 2, mean)
print (ColMeans)
**********************************************************************

Testing apply1.R...

Output (only first 500 characters): 


**********************************************************************
 [1] -0.2107302  0.5873685  0.0336342 -0.5579379 -0.3734603 -0.3276279
 [7] -0.7736824 -0.2801585  0.3098091 -0.3114778
 [1] 1.4623566 2.5121547 1.3652098 0.9128083 1.5109298 0.4534884 0.9405176
 [8] 0.3710130 1.4817573 0.8850862
 [1]  0.03404573 -0.26415035  0.47785469 -0.38868533 -0.39115033  0.39723043
 [7] -0.76728822 -0.28188681 -0.11797618 -0.60225675

**********************************************************************

Code ran without errors

Time consumed = 0.09125s

======================================================================
Inspecting script file basic_io.R...

File contents are:

**********************************************************************
source("basic_io.R")

getwd()

Mydata <- read.csv("../data/trees.csv")
ls(pattern = "my*")

class(Mydata)
head(Mydata)
str(MyData)

MyData <- read.csv("../data/trees.csv", header = F)
head(MyData)

MyData <- read.table("../data/trees.csv", sep = ',', header = TRUE)
head(MyData)

write.csv(MyData, "../Results/MyData.csv")


**********************************************************************

Testing basic_io.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Error: C stack usage  7970788 is too close to the limit
Execution halted

======================================================================
Inspecting script file Girko.R...

File contents are:

**********************************************************************
#Plotting girkos
library(tidyverse)
library(ggplot2)


build_ellipse <- function(hradius, vradius){ # function that returns an ellipse
  npoints = 250
  a <- seq(0, 2 * pi, length = npoints + 1)
  x <- hradius * cos(a)
  y <- vradius * sin(a)  
  return(data.frame(x = x, y = y))
}

N <- 250 # Assign size of the matrix

M <- matrix(rnorm(N * N), N, N) # Build the matrix

eigvals <- eigen(M)$values # Find the eigenvalues

eigDF <- data.frame("Real" = Re(eigvals), "Imaginary" = Im(eigvals)) # Build a dataframe

my_radius <- sqrt(N) # The radius of the circle is sqrt(N)

ellDF <- build_ellipse(my_radius, my_radius) # Dataframe to plot the ellipse

names(ellDF) <- c("Real", "Imaginary") # rename the columns

# plot the eigenvalues
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))
p <- p +
  geom_point(shape = I(3)) +
  theme(legend.position = "none")

# now add the vertical and horizontal line
p <- p + geom_hline(aes(yintercept = 0))
p <- p + geom_vline(aes(xintercept = 0))

# finally, add the ellipse
p <- p + geom_polygon(data = ellDF, aes(x = Real, y = Imaginary, alpha = 1/20, fill = "red"))
p
**********************************************************************

Testing Girko.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.4     ✔ readr     2.1.5
✔ forcats   1.0.0     ✔ stringr   1.5.1
✔ ggplot2   3.5.1     ✔ tibble    3.2.1
✔ lubridate 1.9.3     ✔ tidyr     1.3.1
✔ purrr     1.0.2     
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors

======================================================================
Inspecting script file boilerplate.R...

File contents are:

**********************************************************************
# A boilerplate R script

MyFunction <- function(Arg1, Arg2) {
  #statements involving Arg1, Arg2: 
  print(paste("Arguement", as.character(Arg1), "is a", class(Arg1))) #print Arg1's type 
  print(paste("Arguement", as.character(Arg2), "is a", class(Arg2)))
  
  return (c(Arg1, Arg2)) #this is 
}

MyFunction(1,2) # 1 and 2 will print numeric argument types
MyFunction("Riki", "Tiki") # characters will be character arguments

**********************************************************************

Testing boilerplate.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Arguement 1 is a numeric"
[1] "Arguement 2 is a numeric"
[1] 1 2
[1] "Arguement Riki is a character"
[1] "Arguement Tiki is a character"
[1] "Riki" "Tiki"

**********************************************************************

Code ran without errors

Time consumed = 0.10742s

======================================================================
Inspecting script file apply2.R...

File contents are:

**********************************************************************
SomeOperation <- function(v) { # (What does this function do?)
  if (sum(v) > 0) { #note that sum(v) is a single (scalar) value
    return (v * 100)
  } else { 
    return (v)
  }
}

M <- matrix(rnorm(100), 10, 10)
print (apply(M, 1, SomeOperation)) # 1 means apply yhis function to each row of the matrix
**********************************************************************

Testing apply2.R...

Output (only first 500 characters): 


**********************************************************************
             [,1]      [,2]        [,3]        [,4]       [,5]      [,6]
 [1,]  0.51144271  50.03972 -1.16861061  0.29295984 -0.3734107 -27.89056
 [2,] -3.16904949  86.28237 -0.01231917  0.14275879 -1.1976250 -19.18653
 [3,]  0.07091158 174.19080 -0.88569709 -0.29402720  0.2905166 -39.11931
 [4,]  0.84908304 157.06191 -0.72560557 -2.18588317  0.2522898 -82.34721
 [5,]  0.33246653  56.84636 -0.33851095 -1.97151490 -2.7203078  22.62946
 [6,] -1.37019955  80.65825 -1.09262584  0.03459727 -0.6422054 
**********************************************************************

Code ran without errors

Time consumed = 0.11090s

======================================================================
Inspecting script file DataWrang.R...

File contents are:

**********************************************************************
#importing a dataframe and data wrangling it 
# imported as a matrix (so all data is a string)
# using matrix makes everythign a consistant data type
MyData <- as.matrix(read.csv("../data/PoundHillData.csv", header = FALSE))
class(MyData)

MyMetaData <- read.csv("../data/PoundHillMetaData.csv", header = TRUE, sep=";")
class(MyMetaData)

MyData[MyData == ""] = 0 # we can do this because the data is true zero (absences of species) 

MyData <- t(MyData) #Transposition (t() function):
#The t() function in R takes a matrix or a data frame and transposes it. Transposing means flipping the rows and columns of the data.
head(MyData) #makes it so that months are all in one column , rather then in multiple rows 

colnames(MyData)
MyData

colnames(TempData) <- MyData[1,] # assign column names from original data
head(TempData)

TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important here because we don’t want R to convert columns to the factor class
head(TempData)  

rownames(TempData) <- NULL #gets rid of row names which are particularly important
head(TempData)

TempData

#name we can make the data long form 
MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")
head(MyWrangledData); tail(MyWrangledData)
MyWrangledData

#now that the data is corrected, we can assign the correct data types 
MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])
str(MyWrangledData)

MyWrangledData
require(tidyverse)

tidyverse_packages(include_self = TRUE) # the include_self = TRUE means list "tidyverse" as well 


MyWrangledData <- dplyr::as_tibble(MyWrangledData) #:: allows you to access a particular function (like a python module)
MyWrangledData
class(MyWrangledData)

glimpse(MyWrangledData) # a nice formatted overveiw of the data 


# filtering the data
Count <_ filter(MyWrangledData, Count>100) #like subset(), but nicer!
Species <- filter(MyWrangledData, Species == "Agrostis gigantea") #subsets for these speices 

# slicing the data
slice(MyWrangledData, 10:15) # Look at a particular range of data rows

# pipe operator , which allows you to create a compact sequence of manioutates in yoru data set , needed dplyr

MyWrangledData %>%
  group_by(Species) %>%
  summarise(avg = mean(Count)) #average of each species (this is a really cool function i love this)

aggregate(MyWrangledData$Count, list(MyWrangledData$Species), FUN=mean)





**********************************************************************

Testing DataWrang.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Error in file(file, "rt") : cannot open the connection
Calls: as.matrix -> read.csv -> read.table -> file
In addition: Warning message:
In file(file, "rt") :
  cannot open file '../data/PoundHillData.csv': No such file or directory
Execution halted

======================================================================
Inspecting script file try.R...

File contents are:

**********************************************************************
doit <- function(x) {
  temp_x <- sample(x, replace = TRUE)
  if(length(unique(temp_x)) > 30) {#only take mean if sample was sufficient
    print(paste("Mean of this sample was:", as.character(mean(temp_x))))
  } 
  else {
    stop("Couldn't calculate mean: too few unique values!")
  }
}

set.seed(1345) # again, to get the same result for illustration

popn <- rnorm(50)

hist(popn)

lapply(1:15, function(i) doit(popn))

result <- lapply(1:15, function(i) try(doit(popn), FALSE))
class(result)
result

result <- vector("list", 15) #Preallocate/Initialize
for(i in 1:15) {
  result[[i]] <- try(doit(popn), FALSE)
}

#Error in doit(popn) : Couldn't calculate mean: too few unique values!
**********************************************************************

Testing try.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Mean of this sample was: -0.11620822588674"
[1] "Mean of this sample was: -0.0468516755995931"
[1] "Mean of this sample was: -0.0890228211466614"
[1] "Mean of this sample was: -0.124229742255296"

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Error in doit(popn) : Couldn't calculate mean: too few unique values!
Calls: lapply -> FUN -> doit
Execution halted

======================================================================
Inspecting script file control_flow.R...

File contents are:

**********************************************************************
#if statements
a <- TRUE
if (a == TRUE) {
  print ("a is TRUE")
} else {
  print ("a is FALSE")
}

z <- runif(1) ## Generate a uniformly distributed random number
if (z <= 0.5) {print ("Less than a half")}

#for loops 
for (i in 1:10) {
  j <- i * i
  print(paste(i, " squared is", j ))
}

for(species in c('Heliodoxa rubinoides', 
                 'Boissonneaua jardini', 
                 'Sula nebouxii')) {
  print(paste('The species is', species))
}

v1 <- c("a","bc","def")
for (i in v1) {
  print(i)
}

#while loops 

i <- 0
while (i < 10) {
  i <- i+1
  print(i^2)
}

**********************************************************************

Testing control_flow.R...

Output (only first 500 characters): 


**********************************************************************
[1] "a is TRUE"
[1] "1  squared is 1"
[1] "2  squared is 4"
[1] "3  squared is 9"
[1] "4  squared is 16"
[1] "5  squared is 25"
[1] "6  squared is 36"
[1] "7  squared is 49"
[1] "8  squared is 64"
[1] "9  squared is 81"
[1] "10  squared is 100"
[1] "The species is Heliodoxa rubinoides"
[1] "The species is Boissonneaua jardini"
[1] "The species is Sula nebouxii"
[1] "a"
[1] "bc"
[1] "def"
[1] 1
[1] 4
[1] 9
[1] 16
[1] 25
[1] 36
[1] 49
[1] 64
[1] 81
[1] 100

**********************************************************************

Code ran without errors

Time consumed = 0.11778s

======================================================================
Inspecting script file MyBars.R...

File contents are:

**********************************************************************
library(tidyverse)
library(ggplot2)



a <- read.table("../data/Results.txt", header = TRUE)
head(a)

a$ymin <- rep(0, dim(a)[1]) # append a column of zeros

# Print the first linerange
p <- ggplot(a)
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y1,
  size = (0.5)
),
colour = "#E69F00",
alpha = 1/2, show.legend = FALSE)

# Print the second linerange
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y2,
  size = (0.5)
),
colour = "#56B4E9",
alpha = 1/2, show.legend = FALSE)

# Print the third linerange:
p <- p + geom_linerange(data = a, aes(
  x = x,
  ymin = ymin,
  ymax = y3,
  size = (0.5)
),
colour = "#D55E00",
alpha = 1/2, show.legend = FALSE)

# Annotate the plot with labels:
p <- p + geom_text(data = a, aes(x = x, y = -500, label = Label))

# now set the axis labels, remove the legend, and prepare for bw printing
p <- p + scale_x_continuous("My x axis",
                            breaks = seq(3, 5, by = 0.05)) + 
  scale_y_continuous("My y axis") + 
  theme_bw() + 
  theme(legend.position = "none") 
p
**********************************************************************

Testing MyBars.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.4     ✔ readr     2.1.5
✔ forcats   1.0.0     ✔ stringr   1.5.1
✔ ggplot2   3.5.1     ✔ tibble    3.2.1
✔ lubridate 1.9.3     ✔ tidyr     1.3.1
✔ purrr     1.0.2     
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors
Error in file(file, "rt") : cannot open the connection
Calls: read.table -> file
In addition: Warning message:
In file(file, "rt") :
  cannot open file '../data/Results.txt': No such file or directory
Execution halted

======================================================================
Inspecting script file TreeHeight.R...

File contents are:

**********************************************************************
# This function calculates heights of trees given distance of each tree 
# from its base and angle to its top, using  the trigonometric formula 
#
# height = distance * tan(radians)
Treedata <- read.csv("../data/trees.csv")
# ARGUMENTS
# degrees:   The angle of elevation of tree
# distance:  The distance from base of tree (e.g., meters)
#
# OUTPUT
# The heights of the tree, same units as "distance"

TreeHeight <- function(degrees, distance) {
  radians <- degrees * pi / 180
  height <- distance * tan(radians)
  print(paste("Tree height is:", height))
  
  return (height)
}

Treedata$Tree.Height.m  <- TreeHeight(Treedata$Angle.degrees, Treedata$Distance.m) #applyes function and creates a new colum for it 

write.csv(Treedata, "../results/TreedataR.csv", row.names = FALSE) 


**********************************************************************

Testing TreeHeight.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Error in file(file, "rt") : cannot open the connection
Calls: read.csv -> read.table -> file
In addition: Warning message:
In file(file, "rt") :
  cannot open file '../data/trees.csv': No such file or directory
Execution halted

======================================================================
Inspecting script file plotLin.R...

File contents are:

**********************************************************************
x <- seq(0, 100, by = 0.1)
y <- -4. + 0.25 * x +
  rnorm(length(x), mean = 0., sd = 2.5)

# and put them in a dataframe
my_data <- data.frame(x = x, y = y)

# perform a linear regression
my_lm <- summary(lm(y ~ x, data = my_data))

# plot the data
p <-  ggplot(my_data, aes(x = x, y = y,
                          colour = abs(my_lm$residual))
) +
  geom_point() +
  scale_colour_gradient(low = "black", high = "red") +
  theme(legend.position = "none") +
  scale_x_continuous(
    expression(alpha^2 * pi / beta * sqrt(Theta)))

# add the regression line
p <- p + geom_abline(
  intercept = my_lm$coefficients[1][1],
  slope = my_lm$coefficients[2][1],
  colour = "red")
# throw some math on the plot
p <- p + geom_text(aes(x = 60, y = 0,
                       label = "sqrt(alpha) * 2* pi"), 
                   parse = TRUE, size = 6, 
                   colour = "blue")

p
**********************************************************************

Testing plotLin.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Error in ggplot(my_data, aes(x = x, y = y, colour = abs(my_lm$residual))) : 
  could not find function "ggplot"
Execution halted

======================================================================
Inspecting script file next.R...

File contents are:

**********************************************************************
for (i in 1:10) {
  if ((i %% 2) == 0) # check if the number is odd
    next #pass to next iternation of the loop
  print(i)
}

**********************************************************************

Testing next.R...

Output (only first 500 characters): 


**********************************************************************
[1] 1
[1] 3
[1] 5
[1] 7
[1] 9

**********************************************************************

Code ran without errors

Time consumed = 0.10363s

======================================================================
Inspecting script file browse.R...

File contents are:

**********************************************************************
Exponential <- function(N0 = 1, r = 1, generations = 10) {
  # Runs a simulation of exponential growth
  # Returns a vector of length generations
  
  N <- rep(NA, generations)    # Creates a vector of NA
  
  N[1] <- N0
  for (t in 2:generations) {
    N[t] <- N[t-1] * exp(r)
    browser()
  }
  return (N)
}

plot(Exponential(), type="l", main="Exponential growth")

#i havent finished this 
Browse[1]>
  
#
**********************************************************************

Testing browse.R...

Output (only first 500 characters): 


**********************************************************************
Called from: Exponential()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Error: unexpected end of input

======================================================================
Inspecting script file preallocate.R...

File contents are:

**********************************************************************
NoPreallocFun <- function(x) {
  a <- vector() # empty vector
  for (i in 1:x) {
    a <- c(a, i) # concatenate
    print(a)
    print(object.size(a))
  }
}

system.time(NoPreallocFun(10))

PreallocFun <- function(x) {
  a <- rep(NA, x) # pre-allocated vector
  for (i in 1:x) {
    a[i] <- i # assign
    print(a)
    print(object.size(a))
  }
}

system.time(PreallocFun(10))

p <- ggplot(MyDF, aes(x = log(Prey.mass), y = log(Predator.mass))) +  geom_point() + facet_wrap( .~ Location, scales = "free")
p
**********************************************************************

Testing preallocate.R...

Output (only first 500 characters): 


**********************************************************************
[1] 1
56 bytes
[1] 1 2
56 bytes
[1] 1 2 3
64 bytes
[1] 1 2 3 4
64 bytes
[1] 1 2 3 4 5
80 bytes
[1] 1 2 3 4 5 6
80 bytes
[1] 1 2 3 4 5 6 7
80 bytes
[1] 1 2 3 4 5 6 7 8
80 bytes
[1] 1 2 3 4 5 6 7 8 9
96 bytes
 [1]  1  2  3  4  5  6  7  8  9 10
96 bytes
   user  system elapsed 
   0.01    0.00    0.01 
 [1]  1 NA NA NA NA NA NA NA NA NA
96 bytes
 [1]  1  2 NA NA NA NA NA NA NA NA
96 bytes
 [1]  1  2  3 NA NA NA NA NA NA NA
96 bytes
 [1]  1  2  3  4 NA NA NA NA NA NA
96 bytes
 [1]  1  2  3  4  5 NA N
**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Error in ggplot(MyDF, aes(x = log(Prey.mass), y = log(Predator.mass))) : 
  could not find function "ggplot"
Execution halted

======================================================================
======================================================================
Finished running scripts

Ran into 9 errors

======================================================================
======================================================================

FINISHED LOGGING

